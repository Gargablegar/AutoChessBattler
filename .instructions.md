# AutoChessBattler Development Instructions

This document outlines the development workflow and project structure guidelines for the AutoChessBattler game.

## Project Structure Guidelines

### 1. Test Files Organization
- **All test files must be created and run from the `/test` directory**
- Test files should follow the naming convention: `test_<feature_name>.py`
- Each test file must include proper import path setup to access parent modules:
  ```python
  import sys
  import os
  sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
  ```
- Run tests from the `/test` directory: `cd test && python test_<feature_name>.py`

### 2. Assets and Media Files
- **Game images and binary assets must be placed in the `/svgs` directory**
- Chess piece images follow the naming convention: `<PieceType>_<Color>.svg.png`
  - Examples: `King_White.svg.png`, `Queen_Black.svg.png`, `Pawn_White.svg.png`
- All visual assets should be optimized for game performance
- Maintain consistent image dimensions and quality across all pieces

## Development Workflow

### Testing Strategy
1. **Create comprehensive tests** for all new features before implementation
2. **Test behavior systems** thoroughly - each behavior (aggressive, defensive, passive) should have dedicated test files
3. **Run full test suite** before committing changes:
   ```bash
   cd test
   python test_behavior_system.py
   python test_defensive_behavior.py
   python test_aggressive_behavior.py
   python test_all_behaviors.py
   python test_behavior_combination.py
   python test_passive_game.py
   ```

### Code Organization
- **Core game logic**: Keep main game files in the root directory (`game.py`, `board.py`, `autochess_pieces.py`, `game_ui.py`)
- **Utility scripts**: Place helper scripts and tools in appropriate subdirectories
- **Documentation**: Update `README.md` when adding new features or changing gameplay mechanics

### Feature Development Process
1. **Design**: Plan the feature and its interactions with existing systems
2. **Test-Driven Development**: Write tests first, then implement the feature
3. **Implementation**: Code the feature following existing patterns and conventions
4. **Integration Testing**: Ensure new features work with existing behavior systems
5. **Documentation**: Update relevant documentation and help text

## Behavior System Guidelines

### Behavior Implementation Standards
- **Aggressive Behavior**: Prioritize captures → hunt enemy kings → normal moves
- **Defensive Behavior**: Prioritize captures → guard friendly king (≤5 blocks) → approach king (>5 blocks)
- **Passive Behavior**: No movement whatsoever (0 valid moves)
- **Default Behavior**: Normal random movement with standard chess rules

### Testing Requirements for Behaviors
- Test each behavior in isolation
- Test behavior combinations and interactions
- Test edge cases (no valid moves, no targets, etc.)
- Verify behavior reset functionality after turns
- Test UI behavior icon system integration

## File Naming Conventions

### Test Files
- `test_<system_name>.py` - System-level tests
- `test_<feature_name>_behavior.py` - Behavior-specific tests
- `test_<feature1>_<feature2>.py` - Integration tests between features

### Asset Files
- Chess pieces: `<PieceType>_<Color>.svg.png`
- UI elements: `<element_name>_<variant>.png`
- Icons: `icon_<purpose>.png`

## Quality Standards

### Code Quality
- Follow Python PEP 8 style guidelines
- Include comprehensive docstrings for all classes and methods
- Use type hints where appropriate
- Maintain consistent error handling patterns

### Performance Guidelines
- Keep frame rate at 60 FPS for smooth gameplay
- Optimize asset loading and rendering
- Use efficient algorithms for move calculation and board state management
- Test performance with large board sizes (up to 50x50)

### User Experience
- Provide clear feedback for all user actions
- Display helpful error messages for invalid operations
- Maintain responsive UI during gameplay
- Ensure accessibility with clear visual indicators

## Git Workflow

### Commit Guidelines
- Make focused, atomic commits
- Write clear commit messages describing the change
- Test all functionality before committing
- Update documentation with feature changes

### Branch Strategy
- Use descriptive branch names for feature development
- Keep the main branch stable and functional
- Test thoroughly before merging to main

## Dependencies Management

### Required Dependencies
- `pygame` - Game UI and graphics
- Standard library modules for core functionality

### Installation Process
- Use virtual environments for development
- Keep `requirements.txt` updated with exact versions
- Provide clear setup instructions in `README.md`

## Documentation Standards

### Code Documentation
- Document all public methods and classes
- Include examples in docstrings where helpful
- Explain complex algorithms and behavior logic
- Keep comments up to date with code changes

### User Documentation
- Update `README.md` with new features and changes
- Provide clear usage examples and setup instructions
- Document all command-line options and game controls
- Include behavior system explanations for players

---

**Note**: These instructions should be followed consistently to maintain code quality, project organization, and team collaboration efficiency. When in doubt, refer to existing patterns in the codebase and follow established conventions.
